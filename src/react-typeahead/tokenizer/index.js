import React, { Component } from 'react';
import PropTypes from 'prop-types';
import Token from './token';
import KeyEvent from '../keyevent';
import Typeahead from '../typeahead/index';
import classSet from 'react-classset';

// A typeahead that, when an option is selected replaces the text entry
// widget with a renderable 'token' that can be deleted by pressing
// backspace on the beginning of the line
class TypeaheadTokenizer extends Component {

	constructor(props) {
		super(props);

		// State tracks the following:
		// @selected - holds all user generated tokens to search with
		// 	Ex: [{category: 'id', operator: '=', value: '123'}, ...]
		// @category - which column to search in
		// @operator - the operator to apply to the column
		this.state = {
			selected: this.props.defaultSelected,
			category: '',
			operator: ''
		};
	}


	// Render tokens generated by the user
	_renderTokens() {
		let tokenClasses = {};
		tokenClasses[this.props.customClasses.token] = !!this.props.customClasses.token;
		let classList = classSet(tokenClasses);

		let result = this.state.selected.map(token => {
			let tokenKey = token.category + token.operator + token.value;

			return (
				<Token
					key={tokenKey}
					className={classList}
					onRemove={this.removeTokenForValue}
				>
					{ token }
				</Token>
		       )
		}, this);

		return result;
	}


	// Get the options for querying based on what the user 
	// has selected
	// @return:
	//	column category options if no column has 
	// 		been selected
	// 	operator options if a column category 
	// 		has been selected
	_getOptionsForTypeahead() {
		let categoryType;

		if (this.state.category === '') {
			return this.props.options.map(option =>
					option.columnName)
		} else if (this.state.operator === '') {
			categoryType = this._getCategoryType();
		}

		if (categoryType === 'text') {
			return ['=', '!', 'contains', 'like', 'startsWith', 'endsWith'];
		} else if (categoryType == 'textoptions') {
			return ['=', '!'];
		} else if (categoryType === 'number' ||
				categoryType === 'date') {
			return ['=', '!', '<', '<=', '>', '>='];
		}

		return this.props.options;
	}

	// Show a header for the users current selectable item
	// @return: the header title
	_getHeader() {
		if (this.state.category === '') {
			return 'Category';
		} else if (this.state.category === '') {
			return 'Operator';
		} else {
			return 'Value';
		}

		return this.props.options;
	}

	// Returns the data type the input should use to compare against
	// @return: data type of the column
	// 	i.e. datetime, email, string, integer
	//	defaults to 'string'
	_getInputType() {
		if (this.state.category !== '' &&
			this.state.operator !== '') {
				return this._getCategoryType();
		}

		return 'text';
	}

	// Get the data type of the column
	_getCategoryType() {
		this.props.options.forEach(option => {
			if (option.category === this.state.category) {
				return option.type;
			}
		})
	}

	_onKeyDown(event) {
		// only need to intercept backspaces
		if (event.keyCode !== KeyEvent.DOM_VK_BACK_SPACE) {
			return;
		}

		// Remove a token only when backspace pressed at 
		// beginning of line without a selection
		let entry = this.refs.typeahead.inputRef().getDOMNode();
		if (entry.selectionStart == entry.selectionEnd && 
				entry.selectionStart == 0) {
			if (this.state.operator !== '') {
				this.setState({
					operator: ''
				});
			} else if (this.state.category !== '') {
				this.setState({
					category: ''
				});
			} else {
				// No tokens
				if (!this.state.selected.length) {
					return;
				}
				this._removeTokenForValue(
						this.state.selected[this.state.selected.length - 1]
						);
			}
			event.preventDefault();
		}
	}

	// Remove a token from the users current query
	_removeTokenForValue(value) {
		let index = this.state.selected.indexOf(value);

		if (index === -1) {
			return;
		}
		
		this.setState({
			selected: this.state.selected.filter((token, i) => {
				return i !== index;
			})
		});
		this.props.onTokenRemove(this.state.selected);

		return;
	}

	// Add a token to the users current query
	_addTokenForValue(value) {
		// Handle attaching a category
		if (this.state.category === '') {
			this.setState({
				category: value
			});
			this.refs.typeahead.setEntryText('');
			return;
		}

		// Handle attaching an operator
		if (this.state.operator === '') {
			this.setState({
				operator: value
			});
			this.refs.typeahead.setEntryText('');
			return;
		}

		// Handle attaching a value
		let newValue = {
			category: this.state.category,
			operator: this.state.operator,
			value: value
		};

		this.setState({
			selected: this.state.selected.concat(newValue)
		});
		this.refs.typeahead.setEntryText('');
		
		// call function to update state so table re renders
		this.props.onTokenAdd(this.state.selected);

		this.setState({
			category: '',
			operator: ''
		});

		return;
	}


	render() {
		return (
			<Typeahead 
				ref={typeahead => this.typeahead = typeahead}
				options={this._getOptionsForTypeahead()}
				header={this._getHeader()}
				datatype={this._getInputType()}
				onOptionSelected={this._addTokenForValue}
				onKeyDown={this._onKeyDown}
				placeholder={this.props.placeholder}
				defaultValue={this.props.defaultValue}
			/>
		);
	}
}

TypeaheadTokenizer.defaultProps = {
	options: [],
	defaultSelected: [],
	customClasses: {},
	defaultValue: '',
	placeholder: '',
	onTokenAdd() {},
	onTokenRemove() {}
};


TypeaheadTokenizer.propTypes = {
	options: React.PropTypes.array,
	customClasses: React.PropTypes.object,
	defaultSelected: React.PropTypes.array,
	defaultValue: React.PropTypes.string,
	placeholder: React.PropTypes.string,
	onTokenRemove: React.PropTypes.func,
	onTokenAdd: React.PropTypes.func
};


export default TypeaheadTokenizer;
